import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
import Bowser from 'bowser';
import EventEmitter from 'events';
import { StateBase } from './bases';
import { WalletRepo } from './repository';
import { State } from './types';
import { convertChain, getNameServiceRegistryFromName, Session } from './utils';
export class WalletManager extends StateBase {
  constructor(_chains, _assetLists, wallets, logger, throwErrors = false, defaultNameService, walletConnectOptions, _signerOptions, endpointOptions, sessionOptions) {
    super();
    _defineProperty(this, "chainRecords", []);
    _defineProperty(this, "walletRepos", []);
    _defineProperty(this, "defaultNameService", 'icns');
    _defineProperty(this, "mainWallets", []);
    _defineProperty(this, "coreEmitter", void 0);
    _defineProperty(this, "walletConnectOptions", void 0);
    _defineProperty(this, "session", void 0);
    _defineProperty(this, "repelWallet", true);
    // only allow one wallet type to connect at one time. i.e. you cannot connect keplr and cosmostation at the same time
    _defineProperty(this, "isLazy", void 0);
    // stands for `globalIsLazy` setting
    _defineProperty(this, "throwErrors", void 0);
    _defineProperty(this, "addChains", (chains, assetLists, signerOptions, endpoints) => {
      const newChainRecords = chains.map(chain => convertChain(chain, assetLists, signerOptions, endpoints?.[chain.chain_name], this.isLazy, this.logger));
      newChainRecords.forEach(chainRecord => {
        const index = this.chainRecords.findIndex(chainRecord2 => chainRecord2.name !== chainRecord.name);
        if (index == -1) {
          this.chainRecords.push(chainRecord);
        } else {
          this.chainRecords[index] = chainRecord;
        }
      });
      this.mainWallets.forEach(wallet => {
        wallet.setChains(newChainRecords, false);
      });
      newChainRecords.forEach(chainRecord => {
        const repo = new WalletRepo(chainRecord, this.mainWallets.map(({
          getChainWallet
        }) => getChainWallet(chainRecord.name)));
        repo.setActions({
          viewOpen: this.actions?.viewOpen,
          viewWalletRepo: this.actions?.viewWalletRepo
        });
        repo.wallets.forEach(w => {
          w.setActions({
            data: this.actions?.data,
            state: this.actions?.state,
            message: this.actions?.message
          });
        });
        repo.logger = this.logger;
        repo.repelWallet = this.repelWallet;
        repo.session = this.session;
        const index = this.walletRepos.findIndex(repo2 => repo2.chainName !== repo.chainName);
        if (index == -1) {
          this.walletRepos.push(repo);
        } else {
          this.walletRepos[index] = repo;
        }
      });
    });
    _defineProperty(this, "on", (event, handler) => {
      this.coreEmitter.on(event, handler);
    });
    _defineProperty(this, "off", (event, handler) => {
      this.coreEmitter.off(event, handler);
    });
    _defineProperty(this, "getMainWallet", walletName => {
      const wallet = this.mainWallets.find(w => w.walletName === walletName);
      if (!wallet) {
        throw new Error(`Wallet ${walletName} is not provided.`);
      }
      return wallet;
    });
    _defineProperty(this, "getWalletRepo", chainName => {
      const walletRepo = this.walletRepos.find(wr => wr.chainName === chainName);
      if (!walletRepo) {
        throw new Error(`Chain ${chainName} is not provided.`);
      }
      return walletRepo;
    });
    _defineProperty(this, "getChainWallet", (chainName, walletName) => {
      const chainWallet = this.getMainWallet(walletName).getChainWallet(chainName);
      if (!chainWallet) {
        throw new Error(`${chainName} is not provided!`);
      }
      return chainWallet;
    });
    _defineProperty(this, "getChainRecord", chainName => {
      const chainRecord = this.chainRecords.find(c => c.name === chainName);
      if (!chainRecord) {
        throw new Error(`${chainName} is not provided!`);
      }
      return chainRecord;
    });
    // get chain logo
    _defineProperty(this, "getChainLogo", chainName => {
      const chainRecord = this.getChainRecord(chainName);
      return (
        // until chain_registry fix this
        // chainRecord?.chain.logo_URIs?.svg ||
        // chainRecord?.chain.logo_URIs?.png ||
        // chainRecord?.chain.logo_URIs?.jpeg ||
        chainRecord?.assetList?.assets[0]?.logo_URIs?.svg || chainRecord?.assetList?.assets[0]?.logo_URIs?.png || undefined
      );
    });
    _defineProperty(this, "getNameService", async chainName => {
      let _chainName;
      if (!chainName) {
        if (!this.defaultNameService) {
          throw new Error('defaultNameService is undefined');
        }
        const registry = getNameServiceRegistryFromName(this.defaultNameService);
        if (!registry) {
          throw new Error('Unknown defaultNameService ' + this.defaultNameService);
        }
        _chainName = registry.chainName;
      } else {
        _chainName = chainName;
      }
      return await this.getWalletRepo(_chainName).getNameService();
    });
    _defineProperty(this, "_reconnect", async () => {
      this.logger?.debug('[CORE EVENT] Emit `refresh_connection`');
      this.coreEmitter.emit('refresh_connection');
      const walletName = window.localStorage.getItem('cosmos-kit@1:core//current-wallet');
      if (walletName) {
        await this.getMainWallet(walletName).connect();
        await this.getMainWallet(walletName).getChainWalletList(true)[0]?.connect(true);
      }
    });
    _defineProperty(this, "_restoreAccounts", async () => {
      const walletName = window.localStorage.getItem('cosmos-kit@1:core//current-wallet');
      const accountsStr = window.localStorage.getItem('cosmos-kit@1:core//accounts');
      if (walletName) {
        const mainWallet = this.getMainWallet(walletName);
        mainWallet.activate();
        if (accountsStr && accountsStr !== '[]') {
          const accounts = JSON.parse(accountsStr);
          accounts.forEach(data => {
            const chainWallet = mainWallet.getChainWalletList(false).find(w => w.chainRecord.chain.chain_id === data.chainId && w.namespace === data.namespace);
            chainWallet?.setData(data);
            chainWallet?.setState(State.Done);
          });
        }
      }
      if (walletName && accountsStr && accountsStr !== '[]') {
        await this._reconnect();
      }
    });
    _defineProperty(this, "onMounted", async () => {
      if (typeof window === 'undefined') return;
      const parser = Bowser.getParser(window.navigator.userAgent);
      const env = {
        browser: parser.getBrowserName(true),
        device: parser.getPlatform().type || 'desktop',
        os: parser.getOSName(true)
      };
      this.setEnv(env);
      this.walletRepos.forEach(repo => repo.setEnv(env));
      await Promise.all(this.mainWallets.map(async wallet => {
        wallet.setEnv(env);
        wallet.emitter?.emit('broadcast_env', env);
        wallet.walletInfo.connectEventNamesOnWindow?.forEach(eventName => {
          window.addEventListener(eventName, this._reconnect);
        });
        wallet.walletInfo.connectEventNamesOnClient?.forEach(async eventName => {
          wallet.client?.on?.(eventName, this._reconnect);
        });
        if (wallet.walletInfo.mode === 'wallet-connect') {
          await wallet.initClient(this.walletConnectOptions);
          wallet.emitter?.emit('broadcast_client', wallet.client);
          this.logger?.debug('[WALLET EVENT] Emit `broadcast_client`');
        } else {
          await wallet.initClient();
          wallet.emitter?.emit('broadcast_client', wallet.client);
          this.logger?.debug('[WALLET EVENT] Emit `broadcast_client`');
        }
      }));
      await this._restoreAccounts();
    });
    _defineProperty(this, "onUnmounted", () => {
      if (typeof window === 'undefined') {
        return;
      }
      this.mainWallets.forEach(wallet => {
        wallet.walletInfo.connectEventNamesOnWindow?.forEach(eventName => {
          window.removeEventListener(eventName, this._reconnect);
        });
        wallet.walletInfo.connectEventNamesOnClient?.forEach(async eventName => {
          wallet.client?.off?.(eventName, this._reconnect);
        });
      });
    });
    this.throwErrors = throwErrors;
    this.coreEmitter = new EventEmitter();
    this.logger = logger;
    if (defaultNameService) this.defaultNameService = defaultNameService;
    this.session = new Session(_objectSpread({
      duration: 1800000,
      callback: () => {
        this.mainWallets.forEach(w => w.disconnectAll(false));
        window?.localStorage.removeItem('cosmos-kit@1:core//accounts');
      }
    }, sessionOptions));
    this.walletConnectOptions = walletConnectOptions;
    this.init(_chains, _assetLists, wallets, walletConnectOptions, _signerOptions, endpointOptions);
  }
  init(chains, assetLists, wallets, walletConnectOptions, signerOptions, endpointOptions) {
    this.logger.info(`${chains.length} chains and ${wallets.length} wallets are provided!`);
    this.isLazy = endpointOptions?.isLazy;
    this.chainRecords = chains.map(chain => convertChain(chain, assetLists, signerOptions, endpointOptions?.endpoints?.[chain.chain_name], this.isLazy, this.logger));
    this.mainWallets = wallets.map(wallet => {
      wallet.logger = this.logger;
      wallet.throwErrors = this.throwErrors;
      wallet.session = this.session;
      wallet.walletConnectOptions = this.walletConnectOptions;
      wallet.setChains(this.chainRecords);
      return wallet;
    });
    this.chainRecords.forEach(chainRecord => {
      const repo = new WalletRepo(chainRecord, wallets.map(({
        getChainWallet
      }) => getChainWallet(chainRecord.name)));
      repo.logger = this.logger;
      repo.repelWallet = this.repelWallet;
      repo.session = this.session;
      this.walletRepos.push(repo);
    });
  }
  setWalletRepel(value) {
    this.repelWallet = value;
    this.walletRepos.forEach(repo => repo.repelWallet = value);
    window?.localStorage.setItem('cosmos-kit@1:core//repel-wallet', value.toString());
  }
  get activeRepos() {
    return this.walletRepos.filter(repo => repo.isActive === true);
  }
}