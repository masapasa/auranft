import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/* eslint-disable no-empty */
/* eslint-disable no-console */

import { StateBase } from './bases/state';
/**
 * Store all ChainWallets for a particular Chain.
 */
export class WalletRepo extends StateBase {
  constructor(chainRecord, wallets = []) {
    super();
    _defineProperty(this, "isActive", false);
    _defineProperty(this, "chainRecord", void 0);
    _defineProperty(this, "_wallets", void 0);
    _defineProperty(this, "namespace", 'cosmos');
    _defineProperty(this, "session", void 0);
    _defineProperty(this, "repelWallet", true);
    _defineProperty(this, "getWallet", walletName => {
      return this.wallets.find(w => w.walletName === walletName);
    });
    _defineProperty(this, "openView", () => {
      this.actions?.viewWalletRepo?.(this);
      this.actions?.viewOpen?.(true);
    });
    _defineProperty(this, "closeView", () => {
      this.actions?.viewOpen?.(false);
    });
    _defineProperty(this, "connect", async (walletName, sync) => {
      if (walletName) {
        const wallet = this.getWallet(walletName);
        await wallet?.connect(sync);
      } else {
        this.openView();
      }
    });
    _defineProperty(this, "disconnect", async (walletName, sync) => {
      if (walletName) {
        await this.getWallet(walletName)?.disconnect(sync);
      } else {
        await this.current.disconnect(sync);
      }
    });
    _defineProperty(this, "getRpcEndpoint", async isLazy => {
      for (const wallet of this.wallets) {
        try {
          return await wallet.getRpcEndpoint(isLazy);
        } catch (error) {}
      }
      throw new Error(`No valid RPC endpoint for chain ${this.chainName}!`);
    });
    _defineProperty(this, "getRestEndpoint", async isLazy => {
      for (const wallet of this.wallets) {
        try {
          return await wallet.getRestEndpoint(isLazy);
        } catch (error) {}
      }
      throw new Error(`No valid REST endpoint for chain ${this.chainName}!`);
    });
    _defineProperty(this, "getStargateClient", async () => {
      for (const wallet of this.wallets) {
        try {
          return await wallet.getStargateClient();
        } catch (error) {}
      }
      throw new Error(`Something wrong! Probably no valid RPC endpoint for chain ${this.chainName}.`);
    });
    _defineProperty(this, "getCosmWasmClient", async () => {
      for (const wallet of this.wallets) {
        const client = await wallet.getCosmWasmClient();
        if (client) {
          return client;
        }
      }
      throw new Error(`Something wrong! Probably no valid RPC endpoint for chain ${this.chainName}.`);
    });
    _defineProperty(this, "getNameService", async () => {
      for (const wallet of this.wallets) {
        const service = await wallet.getNameService();
        if (service) {
          return service;
        }
      }
      throw new Error(`Something wrong! Probably no valid RPC endpoint or name service is not registered for chain ${this.chainName}.`);
    });
    this.chainRecord = chainRecord;
    this._wallets = wallets;
    if (this.repelWallet) {
      this.wallets.forEach(w => {
        w.updateCallbacks(_objectSpread(_objectSpread({}, w.callbacks), {}, {
          beforeConnect: async () => {
            this.wallets.forEach(async w2 => {
              if (!w2.isWalletDisconnected && w2 !== w) {
                await w2.disconnect();
              }
            });
          }
        }));
      });
    }
  }
  setEnv(env) {
    this._env = env;
    this.wallets.forEach(w => w.setEnv(env));
  }
  activate() {
    this.isActive = true;
    this.wallets.forEach(w => w.activate());
  }
  get chainName() {
    return this.chainRecord.name;
  }
  get chainLogo() {
    return (
      // until chain_registry fix this
      // this.chainInfo.chain.logo_URIs?.svg ||
      // this.chainInfo.chain.logo_URIs?.png ||
      // this.chainInfo.chain.logo_URIs?.jpeg ||
      this.chainRecord.assetList?.assets[0]?.logo_URIs?.svg || this.chainRecord.assetList?.assets[0]?.logo_URIs?.png || undefined
    );
  }
  get wallets() {
    return this._wallets;
  }
  get isSingleWallet() {
    return this.wallets.length === 1;
  }
  get current() {
    if (!this.repelWallet) {
      this.logger.warn('when `repelWallet` is set false, `current` is always undefined.');
      return void 0;
    }
    return this.wallets.find(w => !w.isWalletDisconnected);
  }
}