import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { CosmWasmClient, SigningCosmWasmClient } from '@cosmjs/cosmwasm-stargate';
import { calculateFee, SigningStargateClient, StargateClient } from '@cosmjs/stargate';
import { TxRaw } from 'cosmjs-types/cosmos/tx/v1beta1/tx';
import { NameService } from '../name-service';
import { State } from '../types';
import { getIsLazy, getNameServiceRegistryFromChainName, isValidEndpoint } from '../utils';
import { WalletBase } from './wallet';
export class ChainWalletBase extends WalletBase {
  // stands for real `chainIsLazy` considered both `globalIsLazy` and `chainIsLazy` settings

  constructor(walletInfo, chainRecord) {
    super(walletInfo);
    _defineProperty(this, "_chainRecord", void 0);
    _defineProperty(this, "rpcEndpoints", void 0);
    _defineProperty(this, "restEndpoints", void 0);
    _defineProperty(this, "_rpcEndpoint", void 0);
    _defineProperty(this, "_restEndpoint", void 0);
    _defineProperty(this, "offlineSigner", void 0);
    _defineProperty(this, "namespace", 'cosmos');
    _defineProperty(this, "isLazy", void 0);
    _defineProperty(this, "getRpcEndpoint", async isLazy => {
      if (this._rpcEndpoint && (await isValidEndpoint(this._rpcEndpoint, getIsLazy(void 0, this.isLazy, this._rpcEndpoint.isLazy, isLazy, this.logger), this.logger))) {
        return this._rpcEndpoint;
      }
      for (const endpoint of this.rpcEndpoints || []) {
        if (await isValidEndpoint(endpoint, getIsLazy(void 0, this.isLazy, endpoint.isLazy, isLazy, this.logger), this.logger)) {
          this._rpcEndpoint = endpoint;
          this.logger?.debug('Using RPC endpoint ' + endpoint);
          return endpoint;
        }
      }
      throw new Error(`No valid RPC endpoint for chain ${this.chainName} in ${this.walletName}!`);
    });
    _defineProperty(this, "getRestEndpoint", async isLazy => {
      if (this._restEndpoint && (await isValidEndpoint(this._restEndpoint, getIsLazy(void 0, this.isLazy, this._restEndpoint.isLazy, isLazy), this.logger))) {
        return this._restEndpoint;
      }
      for (const endpoint of this.restEndpoints || []) {
        if (await isValidEndpoint(endpoint, getIsLazy(void 0, this.isLazy, endpoint.isLazy, isLazy), this.logger)) {
          this._restEndpoint = endpoint;
          this.logger?.debug('Using REST endpoint ' + endpoint);
          return endpoint;
        }
      }
      throw new Error(`No valid Rest endpoint for chain ${this.chainName} in ${this.walletName}!`);
    });
    _defineProperty(this, "getStargateClient", async () => {
      const rpcEndpoint = await this.getRpcEndpoint();
      return StargateClient.connect(rpcEndpoint, this.stargateOptions);
    });
    _defineProperty(this, "getCosmWasmClient", async () => {
      const rpcEndpoint = await this.getRpcEndpoint();
      return CosmWasmClient.connect(rpcEndpoint);
    });
    _defineProperty(this, "getNameService", async () => {
      const client = await this.getCosmWasmClient();
      const registry = getNameServiceRegistryFromChainName(this.chainName);
      return new NameService(client, registry);
    });
    _defineProperty(this, "getSigningStargateClient", async () => {
      const rpcEndpoint = await this.getRpcEndpoint();
      if (!this.offlineSigner) {
        await this.initOfflineSigner();
      }
      return SigningStargateClient.connectWithSigner(rpcEndpoint, this.offlineSigner, this.signingStargateOptions);
    });
    _defineProperty(this, "getSigningCosmWasmClient", async () => {
      const rpcEndpoint = await this.getRpcEndpoint();
      if (!this.offlineSigner) {
        await this.initOfflineSigner();
      }
      return SigningCosmWasmClient.connectWithSigner(rpcEndpoint, this.offlineSigner, this.signingCosmwasmOptions);
    });
    _defineProperty(this, "getSigningClient", async type => {
      switch (type) {
        case 'stargate':
          return await this.getSigningStargateClient();
        case 'cosmwasm':
          return await this.getSigningCosmWasmClient();
        default:
          return this.getSigningStargateClient();
      }
    });
    _defineProperty(this, "estimateFee", async (messages, type, memo, multiplier) => {
      if (!this.address) {
        throw new Error('Address is required to estimate fee. Try connect to fetch address.');
      }
      let gasPrice;
      switch (type) {
        case 'stargate':
          gasPrice = this.signingStargateOptions?.gasPrice;
          break;
        case 'cosmwasm':
          gasPrice = this.signingCosmwasmOptions?.gasPrice;
          break;
        default:
          gasPrice = this.signingStargateOptions?.gasPrice;
          break;
      }
      if (!gasPrice) {
        throw new Error('Gas price must be set in the client options when auto gas is used.');
      }
      const client = await this.getSigningClient(type);
      const gasEstimation = await client.simulate(this.address, messages, memo);
      return calculateFee(Math.round(gasEstimation * (multiplier || 1.3)), gasPrice);
    });
    _defineProperty(this, "sign", async (messages, fee, memo, type) => {
      if (!this.address) {
        throw new Error('Address is required to estimate fee. Try connect to fetch address.');
      }
      const client = await this.getSigningClient(type);
      let usedFee;
      if (typeof fee === 'undefined' || typeof fee === 'number') {
        usedFee = await this.estimateFee(messages, type, memo, fee);
      } else {
        usedFee = fee;
      }
      return await client.sign(this.address, messages, usedFee, memo || '');
    });
    _defineProperty(this, "broadcast", async (signedMessages, type) => {
      const client = await this.getSigningClient(type);
      const txBytes = TxRaw.encode(signedMessages).finish();
      let timeoutMs, pollIntervalMs;
      switch (type) {
        case 'stargate':
          timeoutMs = this.signingStargateOptions?.broadcastTimeoutMs;
          pollIntervalMs = this.signingStargateOptions?.broadcastPollIntervalMs;
          break;
        case 'cosmwasm':
          timeoutMs = this.signingCosmwasmOptions?.broadcastTimeoutMs;
          pollIntervalMs = this.signingCosmwasmOptions?.broadcastPollIntervalMs;
          break;
        default:
          timeoutMs = this.signingStargateOptions?.broadcastTimeoutMs;
          pollIntervalMs = this.signingStargateOptions?.broadcastPollIntervalMs;
          break;
      }
      return client.broadcastTx(txBytes, timeoutMs, pollIntervalMs);
    });
    _defineProperty(this, "signAndBroadcast", async (messages, fee, memo, type) => {
      const signedMessages = await this.sign(messages, fee, memo, type);
      return this.broadcast(signedMessages, type);
    });
    this._chainRecord = chainRecord;
    this.rpcEndpoints = chainRecord.preferredEndpoints?.rpc;
    this.restEndpoints = chainRecord.preferredEndpoints?.rest;
  }
  get chainRecord() {
    return this._chainRecord;
  }
  get chainName() {
    return this.chainRecord.name;
  }
  get chainLogoUrl() {
    return (
      // until chain_registry fix this
      // this.chainInfo.chain.logo_URIs?.svg ||
      // this.chainInfo.chain.logo_URIs?.png ||
      // this.chainInfo.chain.logo_URIs?.jpeg ||
      this.chainRecord.assetList?.assets[0]?.logo_URIs?.svg || this.chainRecord.assetList?.assets[0]?.logo_URIs?.png || undefined
    );
  }
  get stargateOptions() {
    return this.chainRecord.clientOptions?.stargate;
  }
  get signingStargateOptions() {
    return this.chainRecord.clientOptions?.signingStargate || this.chainRecord.clientOptions?.stargate;
  }
  get signingCosmwasmOptions() {
    return this.chainRecord.clientOptions?.signingCosmwasm;
  }
  get preferredSignType() {
    return this.chainRecord.clientOptions?.preferredSignType || 'amino';
  }
  get chain() {
    return this.chainRecord.chain;
  }
  get assets() {
    return this.chainRecord.assetList?.assets;
  }
  get assetList() {
    return this.chainRecord.assetList;
  }
  get chainId() {
    return this.chain?.chain_id;
  }
  get cosmwasmEnabled() {
    return this.chain?.codebase?.cosmwasm_enabled;
  }
  get username() {
    return this.data?.username;
  }
  get address() {
    return this.data?.address;
  }
  setData(data) {
    this._mutable.data = data;
    this.actions?.data?.(data);
    const accountsStr = window.localStorage.getItem('cosmos-kit@1:core//accounts');
    let accounts = accountsStr ? JSON.parse(accountsStr) : [];
    if (typeof data === 'undefined') {
      accounts = accounts.filter(a => a.chainId !== this.chainId || a.namespace !== this.namespace);
    } else {
      accounts = accounts.filter(a => a.chainId !== this.chainId || a.namespace !== this.namespace);
      accounts.push(data);
    }
    window?.localStorage.setItem('cosmos-kit@1:core//accounts', JSON.stringify(accounts));
    this.session?.update();
  }
  initClient(_options) {
    throw new Error('initClient not implemented');
  }
  async update() {
    this.setState(State.Pending);
    this.setMessage(void 0);
    try {
      await this.client.connect?.(this.chainId);
      let account;
      try {
        this.logger?.debug(`Fetching ${this.walletName} ${this.chainId} account.`);
        account = await this.client.getSimpleAccount(this.chainId);
      } catch (error) {
        if (this.rejectMatched(error)) {
          this.setRejected();
          return;
        }
        if (this.client.addChain) {
          await this.client.addChain(this.chainRecord);
          account = await this.client.getSimpleAccount(this.chainId);
        } else {
          throw error;
        }
      }
      this.setData(account);
      this.setState(State.Done);
      this.setMessage(void 0);
    } catch (e) {
      this.logger?.error(e);
      if (e && this.rejectMatched(e)) {
        this.setRejected();
      } else {
        this.setError(e);
      }
    }
    if (!this.isWalletRejected) {
      window?.localStorage.setItem('cosmos-kit@1:core//current-wallet', this.walletName);
    }
  }
  async initOfflineSigner() {
    if (typeof this.client === 'undefined') {
      throw new Error('WalletClient is not initialized');
    }
    this.offlineSigner = await this.client.getOfflineSigner(this.chainId, this.preferredSignType);
  }
}