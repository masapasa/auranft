import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
let _LOGTYPE$ASSERT, _LOGTYPE$CLEAR, _LOGTYPE$COUNT, _LOGTYPE$DEBUG, _LOGTYPE$ERROR, _LOGTYPE$GROUP, _LOGTYPE$GROUPCOLLAPS, _LOGTYPE$GROUPEND, _LOGTYPE$INFO, _LOGTYPE$LOG, _LOGTYPE$TABLE, _LOGTYPE$TIME, _LOGTYPE$TIMEEND, _LOGTYPE$TRACE, _LOGTYPE$WARN;
/* eslint-disable no-console */
export let LOGLEVEL;
(function (LOGLEVEL) {
  LOGLEVEL["ALL"] = "all";
  LOGLEVEL["INFO"] = "info";
  LOGLEVEL["DEBUG"] = "debug";
  LOGLEVEL["WARN"] = "warn";
  LOGLEVEL["ERROR"] = "error";
  LOGLEVEL["OFF"] = "off";
})(LOGLEVEL || (LOGLEVEL = {}));
var LOGTYPE;
(function (LOGTYPE) {
  LOGTYPE["LOG"] = "log";
  LOGTYPE["INFO"] = "info";
  LOGTYPE["ASSERT"] = "asset";
  LOGTYPE["TRACE"] = "trace";
  LOGTYPE["TABLE"] = "table";
  LOGTYPE["GROUP"] = "group";
  LOGTYPE["GROUPCOLLAPSED"] = "groupCollapsed";
  LOGTYPE["GROUPEND"] = "groupEnd";
  LOGTYPE["COUNT"] = "count";
  LOGTYPE["TIME"] = "time";
  LOGTYPE["TIMEEND"] = "timeEnd";
  LOGTYPE["CLEAR"] = "clear";
  LOGTYPE["DEBUG"] = "debug";
  LOGTYPE["WARN"] = "warn";
  LOGTYPE["ERROR"] = "error";
})(LOGTYPE || (LOGTYPE = {}));
function wrap(logLevel, name, message) {
  switch (logLevel) {
    case 'all':
      return [`%c ${name ? name : logLevel} %c ${message}`, 'background: AliceBlue; border-radius: 0.25em; color: DimGrey; font-weight: 500; padding: 0.25em 0.1em;', 'background: none; border-radius: none; color: auto; font-weight: normal; padding: none;'];
    case 'info':
      return [`%c ${name ? name : logLevel} %c ${message}`, 'background: DodgerBlue; border-radius: 0.25em; color: white; font-weight: 500; padding: 0.25em 0.1em;', 'background: none; border-radius: none; color: auto; font-weight: normal; padding: none;'];
    case 'debug':
      return [`%c ${name ? name : logLevel} %c ${message}`, 'background: DarkViolet; border-radius: 0.25em; color: white; font-weight: 500; padding: 0.25em 0.1em;', 'background: none; border-radius: none; color: auto; font-weight: normal; padding: none;'];
    case 'warn':
      return [`%c ${name ? name : logLevel} %c ${message}`, 'background: DarkOrange; border-radius: 0.25em; color: white; font-weight: 500; padding: 0.25em 0.1em;', 'background: none; border-radius: none; color: auto; font-weight: normal; padding: none;'];
    case 'error':
      return [`%c ${name ? name : logLevel} %c ${message}`, 'background: Crimson; border-radius: 0.25em; color: white; font-weight: 500; padding: 0.25em 0.1em;', 'background: none; border-radius: none; color: auto; font-weight: normal; padding: none;'];
  }
}
_LOGTYPE$ASSERT = LOGTYPE.ASSERT;
_LOGTYPE$CLEAR = LOGTYPE.CLEAR;
_LOGTYPE$COUNT = LOGTYPE.COUNT;
_LOGTYPE$DEBUG = LOGTYPE.DEBUG;
_LOGTYPE$ERROR = LOGTYPE.ERROR;
_LOGTYPE$GROUP = LOGTYPE.GROUP;
_LOGTYPE$GROUPCOLLAPS = LOGTYPE.GROUPCOLLAPSED;
_LOGTYPE$GROUPEND = LOGTYPE.GROUPEND;
_LOGTYPE$INFO = LOGTYPE.INFO;
_LOGTYPE$LOG = LOGTYPE.LOG;
_LOGTYPE$TABLE = LOGTYPE.TABLE;
_LOGTYPE$TIME = LOGTYPE.TIME;
_LOGTYPE$TIMEEND = LOGTYPE.TIMEEND;
_LOGTYPE$TRACE = LOGTYPE.TRACE;
_LOGTYPE$WARN = LOGTYPE.WARN;
export class Logger {
  constructor(label, logLevel = LOGLEVEL.INFO) {
    _defineProperty(this, "logLevel", void 0);
    _defineProperty(this, "logType", void 0);
    _defineProperty(this, "label", void 0);
    this.logLevel = logLevel;
    this.label = label;
  }
  compare(constructorLevel, initialLevel) {
    const order = Object.values(LOGLEVEL);
    const constructorLevelIndex = order.indexOf(constructorLevel);
    const initialLevelIndex = order.indexOf(initialLevel);
    if (constructorLevelIndex < initialLevelIndex) {
      return 1;
    } else if (constructorLevelIndex > initialLevelIndex) {
      return -1;
    } else {
      return 0;
    }
  }
  [_LOGTYPE$ASSERT](value, message) {
    if (this.compare(this.logLevel, LOGLEVEL.ALL) >= 0) {
      return console.assert(value, message);
    }
  }
  [_LOGTYPE$CLEAR]() {
    if (this.compare(this.logLevel, LOGLEVEL.OFF) >= 0) {
      return console.clear();
    }
  }
  [_LOGTYPE$COUNT](label) {
    if (this.compare(this.logLevel, LOGLEVEL.ALL) >= 0) {
      return console.count(label);
    }
  }
  [_LOGTYPE$DEBUG](message, label) {
    if (this.compare(this.logLevel, LOGLEVEL.DEBUG) >= 0) {
      return console.debug(...wrap(LOGLEVEL.DEBUG, label ? label : this.label, message));
    }
  }
  [_LOGTYPE$ERROR](message, label) {
    if (this.compare(this.logLevel, LOGLEVEL.ERROR) >= 0) {
      return console.error(...wrap(LOGLEVEL.ERROR, label ? label : this.label, message));
    }
  }
  [_LOGTYPE$GROUP](message, label) {
    if (this.compare(this.logLevel, LOGLEVEL.ALL) >= 0) {
      return console.group(...wrap(LOGLEVEL.ALL, label ? label : this.label, message));
    }
  }
  [_LOGTYPE$GROUPCOLLAPS](message, label) {
    if (this.compare(this.logLevel, LOGLEVEL.ALL) >= 0) {
      return console.groupCollapsed(...wrap(LOGLEVEL.ALL, label ? label : this.label, message));
    }
  }
  [_LOGTYPE$GROUPEND]() {
    if (this.compare(this.logLevel, LOGLEVEL.ALL) >= 0) {
      return console.groupEnd();
    }
  }
  [_LOGTYPE$INFO](message) {
    if (this.compare(this.logLevel, LOGLEVEL.INFO) >= 0) {
      return console.info(...wrap(LOGLEVEL.INFO, this.label, message));
    }
  }
  [_LOGTYPE$LOG](message, label) {
    if (this.compare(this.logLevel, LOGLEVEL.ALL) >= 0) {
      return console.log(...wrap(LOGLEVEL.ALL, label ? label : this.label, message));
    }
  }
  [_LOGTYPE$TABLE](data, columns) {
    if (this.compare(this.logLevel, LOGLEVEL.ALL) >= 0) {
      return console.table(data, columns);
    }
  }
  [_LOGTYPE$TIME](label) {
    if (this.compare(this.logLevel, LOGLEVEL.ALL) >= 0) {
      return console.time(label);
    }
  }
  [_LOGTYPE$TIMEEND](label) {
    if (this.compare(this.logLevel, LOGLEVEL.ALL) >= 0) {
      return console.timeEnd(label);
    }
  }
  [_LOGTYPE$TRACE](label) {
    if (this.compare(this.logLevel, LOGLEVEL.ALL) >= 0) {
      return console.trace(...wrap(LOGLEVEL.ALL, this.label, label));
    }
  }
  [_LOGTYPE$WARN](message, label) {
    if (this.compare(this.logLevel, LOGLEVEL.WARN) >= 0) {
      return console.warn(...wrap(LOGLEVEL.WARN, label ? label : this.label, message));
    }
  }
}